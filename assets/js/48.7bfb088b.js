(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{570:function(e,r,t){"use strict";t.r(r);var n=t(6),a=Object(n.a)({},(function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"数据变化-数据渲染到页面"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据变化-数据渲染到页面"}},[e._v("#")]),e._v(" 数据变化-数据渲染到页面")]),e._v(" "),t("p",[e._v("数据发生变化到将数据渲染到页面有两个阶段："),t("code",[e._v("render")]),e._v("阶段和"),t("code",[e._v("commit")]),e._v("阶段"),t("br"),e._v("\nreact的生命周期函数，在调用"),t("code",[e._v("this.setState")]),e._v("后首先会计算出状态变化，接着将状态变化渲染在视图中"),t("br"),e._v(" "),t("strong",[e._v("render阶段：")]),e._v(" 计算出状态变化（负责调用组件生命周期方法，进行Diff运算）；"),t("strong",[e._v("commit阶段：")]),e._v(" 将状态变化渲染到视图中（根据不同的平台，渲染出响应的页面）"),t("br"),e._v("\nrender阶段中有Reconciler层，而Fiber优化，就发生在Reconciler中，因此也叫做Fiber Reconciler。Fiber其实是一种数据结构，可以用一个纯JS对象来表示：")]),e._v(" "),t("div",{staticClass:"language-javascript line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-javascript"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("const")]),e._v(" fiber "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    stateNode"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[e._v("//节点实例")]),e._v("\n    child"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),t("span",{pre:!0,attrs:{class:"token comment"}},[e._v("//子节点")]),e._v("\n    sibling"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),t("span",{pre:!0,attrs:{class:"token comment"}},[e._v("//兄弟节点")]),e._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("return")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),t("span",{pre:!0,attrs:{class:"token comment"}},[e._v("//父节点")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br"),t("span",{staticClass:"line-number"},[e._v("6")]),t("br")])]),t("h2",{attrs:{id:"react16架构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#react16架构"}},[e._v("#")]),e._v(" React16架构")]),e._v(" "),t("p",[e._v("React16架构可以分为三层：")]),e._v(" "),t("ul",[t("li",[e._v("Scheduler（调度器）——调度任务的优先级，高优先级任务先进入Reconciler")]),e._v(" "),t("li",[e._v("Reconciler（协调器）——负责找出变化的组件")]),e._v(" "),t("li",[e._v("Renderer（渲染器）——负责将变化的组件渲染到页面上\n相较于React15，React16增加了Scheduler")])]),e._v(" "),t("h2",{attrs:{id:"scheduler"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#scheduler"}},[e._v("#")]),e._v(" Scheduler")]),e._v(" "),t("p",[e._v("以浏览器是否有剩余时间作为任务中断的标准，在浏览器中"),t("code",[e._v("requestIdleCallback")]),e._v("这个函数但是React放弃使用")]),e._v(" "),t("ul",[t("li",[e._v("浏览器兼容性")]),e._v(" "),t("li",[e._v("出发频率不稳定\n基于以上原因，React做了polyfill，这就是Scheduler。"),t("br")])]),e._v(" "),t("h2",{attrs:{id:"reconciler-协调器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#reconciler-协调器"}},[e._v("#")]),e._v(" Reconciler(协调器)")]),e._v(" "),t("p",[e._v("stack Reconciler是递归处理虚拟DOM的"),t("br"),e._v("\n以前的Reconciler被命名为stack Reconciler，stackReconciler运作的过程是不能被打断的，必须一直运行"),t("br"),e._v("\nFiber Reconciler每执行一段时间，都会将控制权交还给浏览器，可以分段执行，为了达到这种效果，需要一个调度器Scheduler来运行任务分配。"),t("br"),e._v("\n在React16中 当Scheduler将任务交给Reconciler后，Reconciler会为变化的虚拟DOM打上代表增删更新的标记，整个Scheduler\n与Reconciler的工作都在内存中进行。只有当所有的组件都完成Reconciler的工作，才会统一交给Renderer"),t("br"),e._v("\nFiber Reconciler在执行过程中又可以分为两个阶段：")]),e._v(" "),t("ol",[t("li",[e._v("生成Fiber树（这棵树是在VirtualDOM树的基础上增加额外的信息来生成的，它的本质是一个链表），得出需要更新的节点信息，这个过程是一个渐进的过程，可以被打断")]),e._v(" "),t("li",[e._v("将需要更新的节点一次批量更新，这个过程不能被打断")])]),e._v(" "),t("p",[e._v("render阶段到commit阶段传递了一条包含了不同fiber节点的effect的链表"),t("br")]),e._v(" "),t("ul",[t("li",[e._v("对于要"),t("strong",[e._v("插入DOM")]),e._v("的元素我们会在对应的fiber节点上增加"),t("strong",[e._v("Placement")]),e._v(" effect，")]),e._v(" "),t("li",[e._v("对于需要"),t("strong",[e._v("更新DOM")]),e._v("的元素，我们会在对应的fiber节点上增加"),t("strong",[e._v("Update")]),e._v(" effect，")]),e._v(" "),t("li",[e._v("对于需要"),t("strong",[e._v("删除DOM")]),e._v("的元素，我们会在对应的fiber节点上增加"),t("strong",[e._v("Deletion")]),e._v(" effect，")]),e._v(" "),t("li",[e._v("对于需要"),t("strong",[e._v("更新ref属性的DOM")]),e._v("元素，我哦们会在对应的fiber上增加"),t("strong",[e._v("Ref")]),e._v(" effect，")]),e._v(" "),t("li",[e._v("对于包含"),t("strong",[e._v("useEffect回调执行的fiber")]),e._v("来说，我们会在对应的fiber上增加"),t("strong",[e._v("passive")]),e._v(" effect，")]),e._v(" "),t("li",[e._v("总之，所有与视图相关的操作都有对应的effect"),t("br")])]),e._v(" "),t("p",[e._v("在commit阶段是如何处理链表的每个effect的，commit阶段将状态变化渲染到视图中，更进一步是将effect渲染在视图中，commit阶段又分为三个阶段"),t("br")]),e._v(" "),t("ol",[t("li",[e._v("渲染视图前（beforeMutation阶段）")]),e._v(" "),t("li",[e._v("渲染视图（mutation阶段）")]),e._v(" "),t("li",[e._v("渲染视图后（layout阶段）"),t("br")])]),e._v(" "),t("p",[e._v("placement的effect在mutation阶段执行对DOM节点appendChild操作，这样我们的DOM节点就会被插入到视图中"),t("br"),e._v("\n接下来会在layout阶段调用componentDidMount"),t("br"),e._v("\n对于passiveEffect来说它会在commit阶段的三个子阶段完成以后异步调用useEffect的回调函数")]),e._v(" "),t("h2",{attrs:{id:"renderer-渲染器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#renderer-渲染器"}},[e._v("#")]),e._v(" Renderer（渲染器）")]),e._v(" "),t("p",[e._v("Renderer根据Reconciler为虚拟DOM打的标记，同步执行对应的DOM操作。")]),e._v(" "),t("h2",{attrs:{id:"双缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#双缓存"}},[e._v("#")]),e._v(" 双缓存")]),e._v(" "),t("p",[e._v("在内存中构建并直接替换的技术叫做双缓存"),t("br"),e._v("\nReact中使用双缓存来完成Fiber树的构建和替换对应DOM树的创建和更新")]),e._v(" "),t("h2",{attrs:{id:"双缓存fiber树"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#双缓存fiber树"}},[e._v("#")]),e._v(" 双缓存Fiber树")]),e._v(" "),t("p",[e._v("在React中做多同时存在两颗Fiber树，当前屏幕上显示内容对应的Fiber树称为current Fiber树，正在内存中构建的Fiber树称为workInProgress Fiber树。\ncurrent Fiber树中的Fiber节点被称为current fiber，workInProgress Fiber树中的Fiber节点被称为workInProgress fiber，他们通过alternate属性连接。"),t("br"),e._v("\nReact应用的根节点通过使current指针在不同的Fiber树的rootFiber间切换来完成current Fiber树指向的切换。")]),e._v(" "),t("h2",{attrs:{id:"react-diff"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#react-diff"}},[e._v("#")]),e._v(" react diff")]),e._v(" "),t("p",[t("strong",[e._v("tree diff")]),e._v(":"),t("br")]),e._v(" "),t("ul",[t("li",[e._v("两棵树只对同一层级节点进行比较，只要该节点不存在了，那么该节点与其子节点会被完全删除，不在进行比较\n"),t("strong",[e._v("component diff")]),e._v(":"),t("br")]),e._v(" "),t("li",[e._v("同类型的组件，按照tree diff 比较virtual dom")]),e._v(" "),t("li",[e._v("同类型组件，组件A转化为了组件B，如果virtual dom无变化，可以通过shouldComponentUpdate方法来判断是否重新渲染")]),e._v(" "),t("li",[e._v("不同类型的组件，那么diff算法会把改变的组件判断为dirty component从而替换整个组件的所有节点\n"),t("strong",[e._v("element diff")]),e._v(":"),t("br")]),e._v(" "),t("li",[e._v("插入：新的组件不在原来的tree中，而是全新的节点，则进行插入操作")]),e._v(" "),t("li",[e._v("删除：组件在原来的tree中，但是更新了，则进行删除操作。")]),e._v(" "),t("li",[e._v("移动：组件存在原来的tree中，但是位置发生改变，如果没有key值进行区分，则删除旧的，插入新的，如果存在唯一key值，进行移动操作")])]),e._v(" "),t("p",[e._v("缺点，如果是最后一个到最前面的一个，则所有的element都要发生变动，会造成性能问题")])])}),[],!1,null,null,null);r.default=a.exports}}]);